<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>对读写分离思想的思考</title>
    <link href="/2022/10/11/yuque/%E5%AF%B9%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%80%9D%E6%83%B3%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2022/10/11/yuque/%E5%AF%B9%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%80%9D%E6%83%B3%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<p>工作后一段时间后，慢慢发现读写分离的思想出现过很多。比如在 MySQL 集群中的读写分离，MySQL 引擎 InnoDB 中的 MVCC，以及 JDK 中的 CopyOnWriteArrayList 中都有体现。</p><span id="more"></span><h1 id="一、MySQL-集群读写分离"><a href="#一、MySQL-集群读写分离" class="headerlink" title="一、MySQL 集群读写分离"></a>一、MySQL 集群读写分离</h1><blockquote><p>大多数互联网业务中，往往读多写少,这时候数据库的读会首先成为数据库的瓶颈。如果我们已经优化了 SQL，但是读依旧还是瓶颈时，这时就可以选择“读写分离”架构了。</p></blockquote><h2 id="1、具体实施"><a href="#1、具体实施" class="headerlink" title="1、具体实施"></a>1、具体实施</h2><ul><li>集群分为主从库，主库用来写，可以不加索引，提高写效率，丛库追加索引，提高读效率</li></ul><h2 id="2、带来的问题"><a href="#2、带来的问题" class="headerlink" title="2、带来的问题"></a>2、带来的问题</h2><blockquote><p>主从架构会剧透延迟性，会带来一致性问题，对实时性要求搞的业务会产生影响</p></blockquote><ul><li><strong>写后立刻读</strong>: 在写入数据库之后某个时间内读操作去主库，其他时间去丛库</li><li><strong>二次查询</strong>：先去丛库读，读不到就去主库读，注意别给主库带来太大写压力</li><li><strong>特殊处理</strong>：实时性要求搞的业务读写放在主库，次要业务使用读写分离</li></ul><h1 id="二、InnoDB-的-MVCC"><a href="#二、InnoDB-的-MVCC" class="headerlink" title="二、InnoDB 的 MVCC"></a>二、InnoDB 的 MVCC</h1><blockquote><p>数据库通常使用锁实现隔离性。最近的锁，锁住资源之后禁止其他资源访问，不论是读还是写都会被排斥，但是在读多写少的情况下，对读进行锁互斥就显得没有必要。于是引入了读写锁，主要对读进行加锁。后来发现并发量还是不够，最终出现了 MVCC(Multi-Version Concurrency Control)即 多版本并发控制</p></blockquote><ul><li>MVCC 是 MySQL 引擎 InnoDB 对并发处理的无锁实现<img src="http://lqsgoodboy.oss-cn-shanghai.aliyuncs.com/yuque_hexo//Fp3GkXluaXAMCYJ8nHBvOJ3CgFxn.png"></li></ul><h1 id="三、CopyOnWriteArrayList"><a href="#三、CopyOnWriteArrayList" class="headerlink" title="三、CopyOnWriteArrayList"></a>三、CopyOnWriteArrayList</h1>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
